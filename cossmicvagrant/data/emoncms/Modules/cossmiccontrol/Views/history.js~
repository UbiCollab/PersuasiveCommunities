// create year dropdown selection menu
function create_year_dropdown(element_id, first_year, current_year) {
    year_dropdown = "";
    for (i = first_year; i <= current_year; i++) {
	year_dropdown = year_dropdown + "<option value='"+i+"'>"+i+"</option>";
    }
    $(element_id).append(year_dropdown);
}

// format the date to output
function ds_format_date(d, m, y) {
    // 2 digits month.
    m2 = '00' + m;
    m2 = m2.substr(m2.length - 2);
    // 2 digits day.
    d2 = '00' + d;
    d2 = d2.substr(d2.length - 2);
    // MM/DD/YYYY
    return m2 + '/' + d2 + '/' + y;
}

// multiply y-values in [x,y]-array by a scalar
function scalarMultiplyY(arr, multiplier) {
    for (var i = 0; i < arr.length; i++) {
        arr[i][1] *= multiplier;
    }
}

// returns true if leap year, false otherwise
function isLeapYear(year) {
    return (((year%4==0) && (year%100!=0)) || (year%400==0));
}

// returns number of days in a given month for a given year
function days_in_month(month,year) {
    month = parseInt(month);
    year = parseInt(year);
    var days;
    switch (month) {
        case 0: case 2: case 4: case 6: case 7: case 9: case 11:
            days = 31;
            break;
        case 1:
            days = isLeapYear(year)?29:28;
            break;
        case 3: case 5: case 8: case 10:
            days = 30;
            break;
    }
    return days;
}

// convert feed list to plot list (devices plot)
function convert_to_plotlist(feedlist) {
    var plotlist = [];
    for (var i in feedlist){
        plotlist[i] = {
            id: feedlist[i]['feedid'],
            plot: {
                data: null,
                label: feedlist[i]['devicename']
            }
         };
    }
    return plotlist;
}

// create plot list (consumption/generation plot)
function create_plotlist(feedid1, feedid2, feedid3) {
    var plotlist = [];
    plotlist[0] = {
	id: feedid1,
	plot: {
	    data: null,
	    lines: { fill: true },
	    bars: {fill: true },
	    stack: true
	}
    };
    plotlist[1] = {
        id: feedid2,
	plot: {
	    data: null,
	    lines: { fill: true },
	    bars: {fill: true },
	    stack: true
	}
    };
    plotlist[2] = {
	id: feedid3,
	plot: {
	    data: null
	}
    };
    return plotlist;
}

// get data to be plotted
function get_plotdata_mode(plotlist, start, end, mode) {
    for(var i in plotlist) {
        if (timeWindowChanged)
        {
            plotlist[i].plot.data = null;
        }
        if (!plotlist[i].plot.data)
        {
	    // power (day)
	    if (mode == "day") plotlist[i].plot.data = get_feed_data(plotlist[i].id, start, end, 400);
	    // histogram with kWh/day (month)
	    if (mode == "month") {
		plotlist[i].plot.data = get_feed_data(plotlist[i].id, start, end, 400);
		var kwhtoday = [];
		kwhtoday[0] = new Date().setHours(0,0,0,0);
		kwhtoday[1] = get_feedvalue(plotlist[i].id);
		plotlist[i].plot.data.push(kwhtoday);
	    }
	    // histogram with kWh summed up for each month
	    else if (mode == "year") {
		plotlist[i].plot.data = [];
		var data = get_feed_data(plotlist[i].id, start, end, end-start);
		var d = new Date();
		var month = 0, year = 0, lmonth, lyear;
		var sum = 0, j = 0;
	    	for (var z in data) {
		    lmonth = month;
		    lyear = year;
		    d.setTime(data[z][0]);
		    month = d.getMonth(); year = d.getFullYear();
		    if (month!=lmonth && z!=0) {
			var tmp = [];
			tmp[0] = Date.UTC(lyear,lmonth,1);
			tmp[1] = sum;
			plotlist[i].plot.data[j] = tmp;
      			j++;
			sum = 0;
		    }
		    sum += parseFloat(data[z][1]);
		}
		var tmp = [];
		tmp[0] = Date.UTC(year,month,1);
		tmp[1] = sum;
		plotlist[i].plot.data[j] = tmp;
		var today = new Date();
		if (today.getMonth() == month) plotlist[i].plot.data[j][1] += parseFloat(get_feedvalue(plotlist[i].id));
		else {
		    var kwhtoday = [];
		    kwhtoday[0] = new Date().setHours(0,0,0,0);
		    kwhtoday[1] = get_feedvalue(plotlist[i].id);
		    plotlist[i].plot.data.push(kwhtoday);
		} 
	    }
	    // histogram with kWh summed up for each year
	    else if (mode == "total") {
		plotlist[i].plot.data = [];
		var data = get_feed_data(plotlist[i].id, start, end, end-start);
		var d = new Date();
		var year = 0, lyear;
		var sum = 0, j = 0;
	    	for (var z in data) {
		    lyear = year;
		    d.setTime(data[z][0]);
		    year = d.getFullYear();
		    if (year!=lyear && z!=0) {
			var tmp = [];
			tmp[0] = Date.UTC(lyear,0,1);
			tmp[1] = sum;
			plotlist[i].plot.data[j] = tmp;
      			j++;
			sum = 0;
		    }
		    sum += parseFloat(data[z][1]);
		}
		var tmp = [];
		tmp[0] = Date.UTC(year,0,1);
		tmp[1] = sum;
		plotlist[i].plot.data[j] = tmp;
		var today = new Date();
		if (today.getFullYear() == year) plotlist[i].plot.data[j][1] += parseFloat(get_feedvalue(plotlist[i].id));
		else {
		    var kwhtoday = [];
		    kwhtoday[0] = new Date().setHours(0,0,0,0);
		    kwhtoday[1] = get_feedvalue(plotlist[i].id);
		    plotlist[i].plot.data.push(kwhtoday);
		}
	    }
        }
    }
}

// define devices plot
function define_plot(plotdata, start, end, yaxislabel, placeholder, mode, nr_devices) {
    var options = {
        grid: { show: true, hoverable: false, clickable: false },
        xaxis: { show: true, mode: "time", timezone: "browser", min: start, max: end, minTickSize: [1, "hour"], timeformat: "%H" },
        yaxis: {
	    show: true,
            axisLabel: yaxislabel,
            axisLabelFontSizePixels: 8,
            axisLabelFontFamily: "Verdana, Arial",
            axisLabelPadding: 5,
	    min: 0
        },
        legend: false,
	lines: { show: true },
	bars: { show: false, fill: true, order: 1 }
    };

    if (mode == "month") {
	options.lines.show = false;
	options.bars.show = true;
	options.bars.barWidth = 12*3600*1000/nr_devices;
	options.xaxis.minTickSize = [1, "day"];
	options.xaxis.timeformat = "%e";
    }
    else if (mode == "year") {
	options.lines.show = false;
	options.bars.show = true;
	options.bars.barWidth = 15*24*3600*1000/nr_devices;
	options.xaxis.minTickSize = [1, "month"];
	options.xaxis.timeformat = "%b";
    }
    else if (mode == "total") {
	options.lines.show = false;
	options.bars.show = true;
	options.bars.barWidth = 150*24*3600*1000/nr_devices;
	options.xaxis.minTickSize = [1, "year"];
	options.xaxis.timeformat = "%Y";
    }

    var plot = $.plot(placeholder, plotdata, options);
    return plot;
}

// plot devices that are ticked  
function plotAccordingToChoices(choiceContainer, plotlist, start, end, yaxislabel, placeholder, mode, nr_devices) {
    var plotdata = [];
    $(choiceContainer).find("input:checked").each(function () {
        var key = $(this).attr("name");
        if (key && plotlist[key].plot) {
            plotdata.push(plotlist[key].plot);
        }
    });

    if (plotdata.length >= 0) {
        var plot = define_plot(plotdata, start, end, yaxislabel, placeholder, mode, nr_devices);
	plot.draw();
    }
    timeWindowChanged = 0;
}

// plot stacked and line/bar graphs (consumption/generation plot)
function plot_mode(plotlist, placeholder, showxaxis, on1, on2, mode, start, end) {
    
    var options;

    if (mode == "day") {
	get_plotdata_mode(plotlist, start, end, "day");
        options = {
            grid: { show: true, hoverable: false, clickable: false },
            xaxis: { show: true, mode: "time", timezone: "browser", minTickSize: [1, "hour"], timeformat: "%H", min: start, max: end, labelHeight:15, reserveSpace: true },
            yaxis: { min: 0 },
            yaxes: [{show: true, labelWidth:50}, {position: "right", show: false, labelWidth:25, reserveSpace: true}],
            legend: false,
            lines: { show: true }
    	};
    }
    else if (mode == "month") {
	get_plotdata_mode(plotlist, start, end, "month");
	options = {
            grid: { show: true, hoverable: false, clickable: false },
            xaxis: { show: true, mode: "time", timezone: "browser", minTickSize: [1, "day"], timeformat: "%e", min: start, max: end, labelHeight:15, reserveSpace: true },
            yaxis: { min: 0 },
            yaxes: [{show: true, labelWidth:50}, {position: "right", show: false, labelWidth:25, reserveSpace: true}],
            legend: false,
            lines: { show: false },
	    bars: { show: true, align: "center", fill: false, barWidth: 3600*1000*12} 
    	};
    }
    else if (mode == "year") {
	get_plotdata_mode(plotlist, start, end, "year");
	options = {
            grid: { show: true, hoverable: false, clickable: false },
            xaxis: { show: true, mode: "time", timezone: "browser", minTickSize: [1, "month"], timeformat: "%b", min: start, max: end, labelHeight:15, reserveSpace: true },
            yaxis: { min: 0 },
            yaxes: [{show: true, labelWidth:50}, {position: "right", show: false, labelWidth:25, reserveSpace: true}],
            legend: false,
            lines: { show: false },
	    bars: { show: true, align: "center", fill: false, barWidth: 3600*1000*24*15} 
    	};
    }
    else if (mode == "total") {
	get_plotdata_mode(plotlist, start, end, "total");
  	options = {
            grid: { show: true, hoverable: false, clickable: false },
            xaxis: { show: true, mode: "time", timezone: "browser", minTickSize: [1, "year"], timeformat: "%Y", min: start, max: end, labelHeight:15, reserveSpace: true },
            yaxis: { min: 0 },
            yaxes: [{show: true, labelWidth:50}, {position: "right", show: false, labelWidth:25, reserveSpace: true}],
            legend: false,
            lines: { show: false },
	    bars: { show: true, align: "center", fill: false, barWidth: 3600*1000*24*150} 
    	};
    }

    if (!showxaxis) options.xaxis.tickFormatter = function (val, axis) { return [] };

    var plotdata = [];
    if (on1) {
        plotdata.push(plotlist[0].plot);
    }
    if (on2) {
        plotdata.push(plotlist[1].plot);
    }
    plotdata.push(plotlist[2].plot);

    $.plot(placeholder, plotdata, options);     
    
    timeWindowChanged = 0;
}

// hard-code color indices to prevent them from shifting as devices are ticked/unticked
function hardcode_color(plotlist) {
    var i = 0;
    $.each(plotlist, function (key, val) {
        val.plot.color = i;
        ++i;
    });
}

// hard-code colors (consumption/generation plot)
function hardcode_color_consumption(plotlist) {
    plotlist[0].plot.color = "#FF0000";
    plotlist[1].plot.color = "#088A08";
    plotlist[2].plot.color = "#424242"; 
}

function hardcode_color_generation(plotlist) {
    plotlist[0].plot.color = "#80FF00";
    plotlist[1].plot.color = "#FFFF00";
    plotlist[2].plot.color = "#424242"; 
}

// on click functions for click on legend (consumption/generation plot)
function onConsumptionClick(plotlist, start, end, placeholder, showxaxis, td1, td2, td3, mode) {
    consumption_on = !consumption_on;
    $(td1).toggleClass("off-cell");
    if (!consumption_on) {
	$(td2).addClass("off-cell");
	extenergysupply_on = false;
	$(td3).addClass("off-cell");
	intpowersupply_on = false;
    }
    else {
	$(td2).removeClass("off-cell");
	extenergysupply_on = true;
	$(td3).removeClass("off-cell");
	intpowersupply_on = true;
    }
    plot_mode(plotlist, placeholder, showxaxis, extenergysupply_on, intpowersupply_on, mode, start, end);
}

function onExtEnergySupplyClick(plotlist, start, end, placeholder, showxaxis, td1, td2, mode) {
    extenergysupply_on = !extenergysupply_on;
    $(td2).toggleClass("off-cell");
    consumption_on = extenergysupply_on && intpowersupply_on;
    if (consumption_on) { $(td1).removeClass("off-cell"); } else { if (intpowersupply_on) $(td1).addClass("off-cell"); }
    plot_mode(plotlist, placeholder, showxaxis, extenergysupply_on, intpowersupply_on, mode, start, end);
}

function onIntPowerSupplyClick(plotlist, start, end, placeholder, showxaxis, td1, td3, mode) {
    intpowersupply_on = !intpowersupply_on;
    $(td3).toggleClass("off-cell");
    consumption_on = extenergysupply_on && intpowersupply_on;
    if (consumption_on) { $(td1).removeClass("off-cell"); } else { if (extenergysupply_on) $(td1).addClass("off-cell"); }
    plot_mode(plotlist, placeholder, showxaxis, extenergysupply_on, intpowersupply_on, mode, start, end);
}

function onGenerationClick(plotlist, start, end, placeholder, showxaxis, td1, td2, td3, mode) {
    generation_on = !generation_on;
    $(td1).toggleClass("off-cell");
    if (!generation_on) {
	$(td2).addClass("off-cell");
	selfconsumption_on = false;
	$(td3).addClass("off-cell");
	gridfeedin_on = false;
    }
    else {
	$(td2).removeClass("off-cell");
	selfconsumption_on = true;
	$(td3).removeClass("off-cell");
	gridfeedin_on = true;
    }
    plot_mode(plotlist, placeholder, showxaxis, selfconsumption_on, gridfeedin_on, mode, start, end);
}

function onSelfConsumptionClick(plotlist, start, end, placeholder, showxaxis, td1, td2, mode) {
    selfconsumption_on = !selfconsumption_on;
    $(td2).toggleClass("off-cell");
    generation_on = selfconsumption_on && gridfeedin_on;
    if (generation_on) { $(td1).removeClass("off-cell"); } else { if (gridfeedin_on) $(td1).addClass("off-cell"); }
    plot_mode(plotlist, placeholder, showxaxis, selfconsumption_on, gridfeedin_on, mode, start, end);
}

function onGridFeedInClick(plotlist, start, end, placeholder, showxaxis, td1, td3, mode) {
    gridfeedin_on = !gridfeedin_on;
    $(td3).toggleClass("off-cell");
    generation_on = selfconsumption_on && gridfeedin_on;
    if (generation_on) { $(td1).removeClass("off-cell"); } else { if (selfconsumption_on) $(td1).addClass("off-cell"); }
    plot_mode(plotlist, placeholder, showxaxis, selfconsumption_on, gridfeedin_on, mode, start, end);
}
